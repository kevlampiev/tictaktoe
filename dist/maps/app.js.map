{"version":3,"sources":["ControlPanel.js","Figures.js","Game.js","GameField.js","GameStatus.js","main.js","settings.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../app.js","sourcesContent":["class ControlPanel {\r\n    /**\r\n     * Просто конструктор\r\n     * @param {Settings} _settings ссылка на настройки\r\n     */\r\n    constructor(_settings) {\r\n        this.dimXInput = document.querySelector('input[name=\"dimension-x-input\"]');\r\n        this.dimYInput = document.querySelector('input[name=\"dimension-y-input\"]');\r\n        this.winLengthInput = document.querySelector('input[name=\"length-to-win\"]');\r\n        this.startButton = document.querySelector('button');\r\n        this.settings = _settings;\r\n        this.drawSettings();\r\n    }\r\n\r\n    /**\r\n     * Чтение настроек из панели, попытка их установить в settings\r\n     */\r\n    getSettings() {\r\n        let newParams = {\r\n            dimX: Number(this.dimXInput.value),\r\n            dimY: Number(this.dimYInput.value),\r\n            winLength: Number(this.winLengthInput.value)\r\n        };\r\n        this.settings.init(newParams);\r\n    }\r\n\r\n    /**\r\n     * Простановка значений настроек в соответствующие элементы формы \r\n     */\r\n    drawSettings() {\r\n        this.dimXInput.value = this.settings.dimX;\r\n        this.dimYInput.value = this.settings.dimY;\r\n        this.winLengthInput.value = this.settings.winLength;\r\n    }\r\n}","//Массив возможных букв, которые можно ставить в ячейки \r\n//И классы, как их отображать\r\n\r\nlet figures = [{\r\n        letter: 'X',\r\n        classToDisplay: 'cellWithX',\r\n        cusrorClass: 'turnXCursor'\r\n    },\r\n    {\r\n        letter: '0',\r\n        classToDisplay: 'cellWithZero',\r\n        cusrorImage: 'turnOCursor'\r\n    }\r\n];","class Game {\r\n  /**\r\n   *  Инициализация всех элементов, навешивание обработчиков событий запуск игры\r\n   */\r\n\r\n  get gameStatus() {\r\n    return this._status;\r\n  }\r\n\r\n  set gameStatus(aValue) {\r\n    switch (aValue) {\r\n      case \"playing\":\r\n        this.gameStatusHolder.closeStatusWindow();\r\n        this._status = aValue;\r\n        break;\r\n      case \"win1\":\r\n        this.gameStatusHolder.displayStatus(\"<h2>Игра кончена</h2> <p> Выиграли крестики </p>\");\r\n        this._status = aValue;\r\n        break;\r\n      case \"win2\":\r\n        this.gameStatusHolder.displayStatus(\"<h2>Игра кончена</h2> <p> Выиграли нолики </p>\");\r\n        this._status = aValue;\r\n        break;\r\n      case \"draw\":\r\n        this.gameStatusHolder.displayStatus(\"<h2>Игра кончена</h2> <p> Закончились свободные клетки. Ничья </p>\");\r\n        this._status = aValue;\r\n        break;\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * Сохдает и инициализирует объекты, запучскает игру\r\n   */\r\n  init() {\r\n    this.settings = new Settings();\r\n    this.settings.init({\r\n      dimX: 3,\r\n      dimY: 3,\r\n      winLength: 3\r\n    });\r\n    this.gameField = new GameField();\r\n    this.gameField.init(this.settings, this.makeMove);\r\n    this.controlPanel = new ControlPanel(this.settings);\r\n    this.gameStatusHolder = new GameStatus();\r\n    this.gfArray = [];\r\n    this.movesCount = 0; //Общее количество сделанных шагов\r\n    this.startNewGame();\r\n\r\n    this.controlPanel.startButton.addEventListener(\"click\", event => {\r\n      event.preventDefault();\r\n      this.startNewGame();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Запускает новую игру с настройками, указанными в settings\r\n   */\r\n  startNewGame() {\r\n    this.movesCount = 0;\r\n    this.controlPanel.getSettings();\r\n    this.gameStatus = \"playing\";\r\n    this.nextTurn = 0; //Чья очередь ходить\r\n    //инициализация внутреннего массива. По нему бегать проще\r\n    this.gfArray = new Array(this.settings.dimY);\r\n    for (let i = 0; i < this.settings.dimY; i++) {\r\n      this.gfArray[i] = new Array(this.settings.dimX).fill(\"\");\r\n    }\r\n    this.gameField.renderGameField();\r\n    this.gameField.tdArray.forEach(elem => {\r\n      elem.addEventListener(\"click\", this.makeStep.bind(this));\r\n    });\r\n  }\r\n\r\n\r\n\r\n  makeStep(event) {\r\n    if (this.gameStatus != \"playing\") {\r\n      return;\r\n    }\r\n\r\n    let point = {\r\n      x: event.target.dataset.column,\r\n      y: event.target.dataset.row\r\n    };\r\n\r\n    if (this.gfArray[point.y][point.x] == \"\") {\r\n      this.movesCount++;\r\n      this.gfArray[point.y][point.x] = figures[this.nextTurn].letter;\r\n\r\n      this.gameField.putFigure(\r\n        event.target,\r\n        figures[this.nextTurn].classToDisplay\r\n      );\r\n      //Проверяем, выиграл ли кто-нибудь. Если - нет, а вдруг поле заполнено\r\n      let winCombo = this.getWinCombination(point.x, point.y);\r\n      if (winCombo.length > 0) {\r\n\r\n        this.selectWinCells(winCombo);\r\n        //закрыть игру\r\n        if (this.nextTurn == 0) {\r\n          this.gameStatus = \"win1\";\r\n        } else {\r\n          this.gameStatus = \"win2\";\r\n        }\r\n\r\n      } else if (this.movesCount >= this.settings.dimX * this.settings.dimY) {\r\n        this.gameStatus = \"draw\";\r\n        alert('никто не выиграл');\r\n      }\r\n\r\n      this.switchTurn();\r\n\r\n\r\n    }\r\n    event.stopPropagation();\r\n  }\r\n\r\n  /**\r\n   * Переключает ход с крестика-на нолик и наоборот\r\n   */\r\n  switchTurn() {\r\n    this.nextTurn++;\r\n    if (this.nextTurn > figures.length - 1) {\r\n      this.nextTurn = 0;\r\n    }\r\n  }\r\n  /**\r\n   * Функция, возвращающая выигрышную комбинацию\r\n   * @param {number} x положение по горизонтали от которого ищутся выигрышные комбинации\r\n   * @param {number} y положение по вертикали от которого ищутся выигрышные комбинации\r\n   * Возвращает массив точек (х,y) соответствующих выигрышной линии или null, если такой нет\r\n   */\r\n  getWinCombination(x, y) {\r\n    let currentLetter = figures[this.nextTurn].letter;\r\n    let gArr = this.gfArray;\r\n    let wLenght = this.settings.winLength;\r\n\r\n    //Вспомогательная внутренния функция\r\n    //До ее запуска определяем сколько шагов по вертикали и горизонтали можем сделать назад и вперед, для составления\r\n    //выигрышной комбинации. Проверяем комбинации для 4х линий\r\n    function getWinComboLines() {\r\n      let result = [];\r\n      let currentX = x0;\r\n      let currentY = y0;\r\n      let letterInArr = \"\";\r\n      for (let i = 0; i < steps; i++) {\r\n        letterInArr = gArr[currentY][currentX];\r\n\r\n        if (letterInArr == currentLetter) {\r\n          result.push({\r\n            x: currentX,\r\n            y: currentY\r\n          });\r\n        } else if (result.length < wLenght) {\r\n          result = [];\r\n        }\r\n        currentX += dX;\r\n        currentY += dY;\r\n      }\r\n\r\n      if (result.length >= wLenght) {\r\n        return result;\r\n      } else {\r\n        return [];\r\n      }\r\n    }\r\n\r\n\r\n    //1 возможная линия идет слева-направо и сверху-вниз\r\n\r\n    let stepBack = Math.min(x, y, this.settings.winLength - 1);\r\n    let stepForward = Math.min(\r\n      this.settings.dimX - x - 1,\r\n      this.settings.dimY - y - 1,\r\n      this.settings.winLength - 1\r\n    );\r\n    let x0 = x * 1 - stepBack;\r\n    let y0 = y * 1 - stepBack;\r\n    let steps = stepBack + 1 + stepForward;\r\n    let dX = 1;\r\n    let dY = 1;\r\n    let line1 = getWinComboLines();\r\n\r\n    //2 возможная линия идет слева-направо строго по горизонтали\r\n\r\n    stepBack = Math.min(x, this.settings.winLength - 1);\r\n    stepForward = Math.min(\r\n      this.settings.dimX - x - 1,\r\n      this.settings.winLength - 1\r\n    );\r\n\r\n    x0 = x - stepBack;\r\n    y0 = y * 1;\r\n    steps = stepBack + 1 + stepForward;\r\n    dX = 1;\r\n    dY = 0;\r\n    let line2 = getWinComboLines();\r\n\r\n    //3 возможная линия идет слева-направо и снизу-вверх\r\n    stepBack = Math.min(\r\n      x * 1,\r\n      this.settings.winLength - 1,\r\n      Math.max(this.settings.dimY - y - 1, 0)\r\n    );\r\n    stepForward = Math.min(\r\n      this.settings.dimX - x - 1,\r\n      y,\r\n      this.settings.winLength - 1\r\n    );\r\n    x0 = x - stepBack;\r\n    y0 = y * 1 + stepBack;\r\n    steps = stepBack + 1 + stepForward;\r\n    dX = 1;\r\n    dY = -1;\r\n    let line3 = getWinComboLines();\r\n\r\n    //4 возможная линия идет строго вниз\r\n    stepBack = Math.min(y * 1, this.settings.winLength - 1);\r\n    stepForward = Math.min(\r\n      this.settings.dimY - y - 1,\r\n      this.settings.winLength - 1\r\n    );\r\n    x0 = x * 1;\r\n    y0 = Math.max(y * 1 - stepBack, 0);\r\n    steps = stepBack + 1 + stepForward;\r\n    dX = 0;\r\n    dY = 1;\r\n    let line4 = getWinComboLines();\r\n\r\n    return line1\r\n      .concat(line2)\r\n      .concat(line3)\r\n      .concat(line4);\r\n  }\r\n\r\n  /**\r\n   * Подсвечивает все точки массива на доске\r\n   * @param {array} arr массив выигрышных точек {x,y}\r\n   */\r\n  selectWinCells(arr) {\r\n    this.gameField.tdArray.forEach(el => {\r\n      el.classList.add('fadedCell');\r\n    });\r\n    arr.forEach(el => {\r\n      this.gameField.getCellByXY(el.x, el.y).classList.remove('fadedCell');\r\n    });\r\n\r\n\r\n\r\n  }\r\n\r\n  run() {\r\n\r\n  }\r\n\r\n  done() {}\r\n}","class GameField {\r\n    /**\r\n     * Просто конструктор, ищет элемент поля, устанавливает очередность хода крестиками\r\n     * @throws {Error} если не найдет .game-field table вызыввется исключение\r\n     */\r\n    constructor() {\r\n        this.gameFieldElem = document.querySelector('.game-field table');\r\n        if (this.gameFieldElem == null) {\r\n            throw new Error('Объект \".game-field table\" отсутствует в документе');\r\n        }\r\n\r\n    }\r\n    /**\r\n     * Получение настроек для отрисовки и поля и начала игры, инициализация игрового массива\r\n     * @param {Settings} _settings объект настроек\r\n     */\r\n    init(_settings, _onClickHandler) {\r\n        this.settings = _settings;\r\n        this.onClickHandler = _onClickHandler;\r\n    }\r\n\r\n    /**\r\n     * Метод отрисовки пустого игрового поля. И сразу подключаем eventListener к\r\n     * внось отрисованным ячейкам\r\n     */\r\n    renderGameField() {\r\n        this.gameFieldElem.innerHTML = '';\r\n        for (let i = 0; i <= (this.settings.dimY - 1); i++) {\r\n            let tr = document.createElement('tr');\r\n            this.gameFieldElem.appendChild(tr);\r\n            for (let j = 0; j <= (this.settings.dimX - 1); j++) {\r\n                let td = document.createElement('td');\r\n                td.dataset.row = i;\r\n                td.dataset.column = j;\r\n                td.addEventListener('click', this.onClickHandler);\r\n                tr.appendChild(td);\r\n            }\r\n        }\r\n        this.tdArray = this.gameFieldElem.querySelectorAll('td');\r\n\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} x номер ячейки по горизонтали. Нумерация начинается с 0 \r\n     * @param {number} y номер ячейки по верикали. Нумерация с 0\r\n     */\r\n    getCellByXY(x, y) {\r\n        return this.gameFieldElem.querySelector(`tr:nth-child(${y+1}) td:nth-child(${x+1})`);\r\n    }\r\n\r\n    /**\r\n     *Возвращает координыты ячейки для псевдомасива \r\n     * @param {Object} cell передается объект ячейки игрового поля, по которому кликнули, например \r\n     */\r\n    getXYOfCell(cell) {\r\n        return {\r\n            x: cell.dataset.column,\r\n            y: cell.dataset.row\r\n        }\r\n    }\r\n\r\n    putFigure(cell, className) {\r\n        cell.classList.add(className);\r\n    }\r\n\r\n}","class GameStatus {\r\n    constructor() {\r\n        this.statusName = \"playing\";\r\n        this.statusWindow = document.querySelector('.statusWindow');\r\n        this.statusTextContainer = document.querySelector('.statusWindow div');\r\n        this.statusWindow.querySelector('button').addEventListener('click', this.closeStatusWindow.bind(this));\r\n    }\r\n\r\n    displayStatus(statusMessage) {\r\n        this.statusWindow.classList.remove('hiddenElement');\r\n        this.statusTextContainer.innerHTML = statusMessage;\r\n    }\r\n\r\n    closeStatusWindow() {\r\n        this.statusWindow.classList.add('hiddenElement');\r\n    }\r\n\r\n\r\n\r\n\r\n}","window.addEventListener('load', () => {\r\n    let game = new Game();\r\n\r\n    game.init();\r\n    game.run();\r\n    game.done()\r\n});","class Settings {\r\n\r\n    constructor() {\r\n\r\n    }\r\n    /**\r\n     * \r\n     * @param {Object} _params - параметры игры\r\n     * @param {number} _params.dimX - размерность поля по горизонтали\r\n     * @param {number} _params.dimY - размерность поля по вертикали\r\n     * @param {number} _params.winLength - необходимое количество крестиков или ноликов в ряд для победы\r\n     * @throws {Error} если переданы неверные настройки, выбрасывается ошибка\r\n     */\r\n    init(_params) {\r\n        if (_params.dimX < 3 || _params.dimX > 21) {\r\n            throw new Error('Размерность по горизонтали должна быть в пределах [3..21]');\r\n        }\r\n        this.dimX = _params.dimX;\r\n\r\n        if (_params.dimY < 3 || _params.dimY > 21) {\r\n            throw new Error('Размерность по вертикали должна быть в пределах [3..21]');\r\n        }\r\n        this.dimY = _params.dimY;\r\n\r\n        if (_params.winLength < 3 || _params.winLength > Math.max(_params.dimX, _params.dimY)) {\r\n            throw new Error('Количество фигур в ряд должно быть не меньше трех и не больше максимальной размерности поля');\r\n        }\r\n        this.winLength = _params.winLength;\r\n\r\n    }\r\n}"]}